{"tagline":"BDDfy is the simplest BDD framework EVER! ","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"## What's with the name?\r\nThe framework is called BDDfy because it BDDfies (as in turns into BDD) your otherwise traditional unit tests. Oh and BTW it is pronounced B D Defy. With BDDfy it is very simple to turn your AAA tests into a BDD test/behavior. BDDfy can work with any and all testing frameworks. In fact, it works even if you are not using any testing framework.\r\n\r\nThe framework is explained on Mehdi Khalili's blog series in full details [here] (http://www.mehdi-khalili.com/bddify-in-action/introduction).\r\n\r\n## How to get going\r\n1. Install NuGet if you have not already.\r\n2. Go to 'Tools', 'Library Package Manager', and click 'Package Manager Console'.\r\n3. In the console, type 'Install-Package TestStack.BDDfy' and enter. \r\n\r\nThis adds the BDDfy assembly to your test project. \r\n\r\nIf this is the first time you are using BDDfy you may want to check out some of the samples on NuGet. Just search NuGet for BDDfy and you will see a list of BDDfy samples. You may install one or more samples to see how the framework works. Each sample installs required packages (including BDDfy and NUnit).\r\n\r\n## Highlights\r\n* BDDfy can run with any testing framework. It does not force you to use any particular framework. Actually BDDfy does not force you to use a testing framework at all. You can just apply it on POCO classes even in a console app if that is what you need!\r\n* BDDfy does not need a separate test runner. You can use your runner of choice. For example, if you like NUnit, then you may write your BDDfy tests using NUnit and run them using NUnit console or GUI runner, Resharper or TD.Net and regardless of the runner, you will get the same result. This means it integrates with the tools you know and love instead of adding yet another one on the top of them.\r\n* BDDfy can run standalone scenarios. Although BDDfy supports stories, you do not necessarily have to have or make up a story to use BDDfy. This is useful for developers who work in non-Agile environments but would like to get some decent testing experience.\r\n* You can use underscored or pascal or camel cased method names for your steps.\r\n* You do not have to explain your scenarios or stories or steps in string: BDDfy infers them based on conventions but you can override the conventions if you need full control over what gets printed into console and HTML reports. Conventions galore in BDDfy and pretty much everything has a convention; but it is also very easy to override these conventions.\r\n* BDDfy is very extensible. In fact, BDDfy core barely has any logic in it. It delegates all its responsibilities to its extensions.\r\n* BDDfy learning curve is rather flat. Not only that but it makes learning BDD effortless.\r\n\r\n##Quick start\r\nNow that you have installed BDDfy, write your first test (this test is borrowed from ATM sample that you can install using nuget package TestStack.BDDfy.Samples):\r\n\r\n\t[Story(\r\n    AsA = \"As an Account Holder\",\r\n    IWant = \"I want to withdraw cash from an ATM\",\r\n    SoThat = \"So that I can get money when the bank is closed\")]\r\n\tpublic class AccountHasInsufficientFund\r\n\t{\r\n\t    private Card _card;\r\n\t    private Atm _atm;\r\n\t\r\n\t    // You can override step text using executable attributes\r\n\t    [Given(StepText = \"Given the account balance is $10\")]\r\n\t    void GivenAccountHasEnoughBalance()\r\n\t    {\r\n\t        _card = new Card(true, 10);\r\n\t    }\r\n\t\r\n\t    void AndGivenTheCardIsValid()\r\n\t    {\r\n\t    }\r\n\t\r\n\t    void AndGivenTheMachineContainsEnoughMoney()\r\n\t    {\r\n\t        _atm = new Atm(100);\r\n\t    }\r\n\t\r\n\t    void WhenTheAccountHolderRequests20()\r\n\t    {\r\n\t        _atm.RequestMoney(_card, 20);\r\n\t    }\r\n\t\r\n\t    void ThenTheAtmShouldNotDispenseAnyMoney()\r\n\t    {\r\n\t        Assert.AreEqual(0, _atm.DispenseValue);\r\n\t    }\r\n\t\r\n\t    void AndTheAtmShouldSayThereAreInsufficientFunds()\r\n\t    {\r\n\t        Assert.AreEqual(DisplayMessage.InsufficientFunds, _atm.Message);\r\n\t    }\r\n\t\r\n\t    void AndTheCardShouldBeReturned()\r\n\t    {\r\n\t        Assert.IsFalse(_atm.CardIsRetained);\r\n\t    }\r\n\t\r\n\t    [Test]\r\n\t    public void Execute()\r\n\t    {\r\n\t        this.BDDfy();\r\n\t    }\r\n\t}\r\n\r\n\r\nAnd this gives you a report like:\r\n\r\n\tStory: Account holder withdraws cash\r\n    \tAs an Account Holder\r\n    \tI want to withdraw cash from an ATM\r\n    \tSo that I can get money when the bank is closed\r\n\r\n\tScenario: Account has insufficient fund\r\n    \tGiven the account balance is $10\r\n      \t\tAnd the card is valid\r\n    \tWhen the account holder requests $20\r\n    \tThen the atm should not dispense any money\r\n      \t\tAnd the atm should say there are insufficient funds\r\n      \t\tAnd the card should be returned\r\n\r\nThis is just the console report. Have a look at your output folder and you should see a nice html report too.\r\n\r\nIf you want more control you can also use BDDfy's Fluent API. Here is another example done using the Fluent API:\r\n\r\n\r\n\t[Test]\r\n\tpublic void CardHasBeenDisabled()\r\n\t{\r\n\t    this.Given(s => s.GivenTheCardIsDisabled())\r\n\t        .When(s => s.WhenTheAccountHolderRequests(20))\r\n\t        .Then(s => s.CardIsRetained(true), \"Then the ATM should retain the card\")\r\n\t            .And(s => s.AndTheAtmShouldSayTheCardHasBeenRetained())\r\n\t        .BDDfy(htmlReportName: \"ATM\");\r\n\t}\r\n\r\nwhich gives you a report like:\r\n\r\n\tScenario: Card has been disabled\r\n    \tGiven the card is disabled\r\n    \tWhen the account holder requests 20\r\n    \tThen the ATM should retain the card\r\n      \t\tAnd the atm should say the card has been retained\r\n\r\n\r\n##How does BDDfy work?\r\nBDDfy uses quite a few conventions to make it frictionless to use. For your convenience, I will try to provide a quick tutorial below:\r\n\r\n###Finding steps\r\nBDDfy scans your BDDfyed classes for steps. Currently it has three ways of finding a step: \r\n\r\n* Using attributes \r\n* Using method name conventions \r\n* And using fluent API.\r\n\r\nBDDfy runs your steps in the following order: SetupState, ConsecutiveSetupState, Transition, ConsecutiveTransition, Assertion, ConsecutiveAssertion and TearDown. Some of these steps are reported in the console and html reports and some of them are not. Please read below for further information.\r\n\r\n###Attributes\r\nBDDfy looks for a custom attribute called ExecutableAttribute on your method. To make it easier to use, ExecutableAttribute has a few subclasses that you can use: you may apply Given, AndGiven, When, AndWhen, Then, and AndThen attributes on any method you want to make available to BDDfy.\r\n\r\n###Method name convention\r\nBDDfy uses some conventions to find methods that should be turned into steps. Here is the current conventions. The method name:\r\n\r\n* ending with \"Context\" is considered as a setup method (not reported).\r\n* \"Setup\" is considered as as setup method  (not reported). \r\n* starting with \"Given\" is considered as a setup method (reported). \r\n* starting with \"AndGiven\" is considered as a setup method that runs after Context, Setup and Given steps reported).\r\n* starting with \"When\" is considered as a transition method  (reported). \r\n* starting with \"AndWhen\" is considered as a transition method that runs after When steps (reported).\r\n* starting with \"Then\" is considered as an asserting method (reported).\r\n* starting with \"And\" is considered as an asserting method (reported).\r\n* starting with \"TearDown\" is considered as a finally method which is run after all the other steps (not reported).\r\n\r\nAs you see in the above example you can mix and match the executable attributes and method name conventions to acheive great flexibility and power.\r\n\r\n###Fluent API\r\nFluent API gives you the absolute power over step selection and their titles. When you use Fluent API for a test, the attributes and method name conventions are ignored for that test. \r\n\r\nPlease note that you can have some tests using fluent API and some using a combination of attributes and method name conventions. Each .BDDfy() test works in isolation of others.\r\n\r\n###Other conventions\r\nBDDfy prefers convention over configuration; but it also allows you to configure pretty much all the conventions. \r\n\r\n## Authors and Contributors\r\nMehdi Khalili (@MehdiK), Michael Whelan (@mwhelan)","name":"BDDfy"}